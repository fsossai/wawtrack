#include <unordered_map>
#include <unordered_set>
#include <map>

#include "llvm/Pass.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/InstIterator.h"
#include "llvm/IR/Instructions.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/ADT/SparseBitVector.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/Analysis/AliasAnalysis.h"
#include "llvm/Analysis/PostDominators.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"
#include "llvm/Transforms/Utils/Cloning.h"

#include "llvm/IR/BasicBlock.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"

using namespace llvm;

namespace {
  constexpr int SBVElementSize = 128;
  constexpr int MAX_CALLS = 1;
  using Bits = SparseBitVector<SBVElementSize>;

  struct CAT : public ModulePass {
    static char ID;

    CAT() : ModulePass(ID) {}

    enum CAT_TYPE { CAT_INVALID, CAT_NEW, CAT_ADD, CAT_SUB, CAT_SET, CAT_GET };

    struct FunctionMetadata {
      FunctionMetadata() {
      }

      const std::vector<const Instruction*>& getMustAlias(Value* target) {
        if (mustAliasMemo.count(target)) {
          return mustAliasMemo[target];
        }
        auto &v = mustAliasMemo[target];
        for (const auto &i1 : instructions(F)) {
          if (aa->alias(target, &i1) == AliasResult::MustAlias) {
            v.push_back(&i1);
          }
        }
        return v;
      }

      const std::vector<const Instruction*>& getMayAlias(Value* target) {
        if (mayAliasMemo.count(target)) {
          return mayAliasMemo[target];
        }
        auto &v = mayAliasMemo[target];
        for (const auto &i1 : instructions(F)) {
          if (aa->alias(target, &i1) == AliasResult::MayAlias) {
            v.push_back(&i1);
          }
        }
        return v;
      }

      void initialize(Function &F, AAResults &alias) {
        this->F = &F;
        int index = 0;
        for (const auto &bb : F) {
          for (const auto &inst : bb) {
            instToIndex[&inst] = index++;
            indexToInst.push_back(&inst);
          }
        }

        pdt = PostDominatorTree(F);

        aa = &alias;

        /*
        for (const auto &i : instructions(F)) {
          if (const auto &store = dyn_cast<StoreInst>(&i)) {
            if (getCATFuncType(store->getValueOperand()) == CAT_NEW) {
              storeEscapes[store->getPointerOperand()].insert(store->getValueOperand());
            }
          }
        }
        */
      }

      /*
      // refining LLVM's Alias Analysis
      void refine() {
      std::map<const Value*, std::set<const Value*>> toErase;
      for (const auto &[i1, s] : mayAlias) {
      //errs() << *i1 << "\n";
      for (const auto &i2 : s) {
      //errs() << "\t" << *i2 << "\n";
      // check for CAT_new-declared CAT variables that
      // never touch memory or other functions (except CAT functions)
      if (getCATFuncType(i1) == CAT_NEW && getCATFuncType(i2) == CAT_NEW) {
      auto i1Escapes = false;
      auto i2Escapes = false;
      // basic escape analysis
      for (const auto &user : i1->users()) {
      if (getCATFuncType(user) == CAT_INVALID) {
      i1Escapes = true;
      }
      }
      for (const auto &user : i2->users()) {
      if (getCATFuncType(user) == CAT_INVALID) {
      i2Escapes = true;
      }
      }
      // if _both variables_ escape, stop
      if (i1Escapes && i2Escapes) {continue;}

      //errs() << "\t(Removing this alias pair)\n";

      toErase[i1].insert(i2);
      toErase[i2].insert(i1);
      }
      }
      }

      for (const auto &[i1, s] : toErase) {
      for (const auto &i2 : s) {
      mayAlias[i1].erase(i2);
      }
      }
      }
      */

      Function *F;
      PostDominatorTree pdt;
      AAResults *aa;
      std::map<const Value*, std::set<const Value*>> storeEscapes;
      std::unordered_map<const Instruction*, int> instToIndex;
      std::vector<const Instruction*> indexToInst;
      std::vector<Bits> gen, kill, in, out;
      std::vector<std::vector<Bits>> argDefs;

      // private:
      std::unordered_map<const Value*, std::vector<const Instruction*>> mustAliasMemo; // memoized alias sets
      std::unordered_map<const Value*, std::vector<const Instruction*>> mayAliasMemo;
    };

    struct ModuleMetadata : std::unordered_map<const Function*, FunctionMetadata> {
      ModuleMetadata(Module &M) : M(M) {
      }

      Module &M;
    };

    //using ModuleMetadata = std::map<const Function*>

    static CAT_TYPE getCATFuncType(const Value *value) {
      if (value == nullptr || !isa<CallInst>(value)) {
        return CAT_INVALID;
      }
      const auto calledFuncName = cast<CallInst>(value)->getCalledFunction()->getName().str();
      if (calledFuncName == "CAT_new") return CAT_NEW;
      if (calledFuncName == "CAT_add") return CAT_ADD;
      if (calledFuncName == "CAT_sub") return CAT_SUB;
      if (calledFuncName == "CAT_set") return CAT_SET;
      if (calledFuncName == "CAT_get") return CAT_GET;
      return CAT_INVALID;
    }

    static std::set<const Value*> getEscapedCATValues(FunctionMetadata &meta, const Instruction *inst) {
      std::set<const Value*> escapes;
      if (const auto &callInst = dyn_cast<CallInst>(inst)) {
        for (const auto &op : callInst->args()) {
          if (getCATFuncType(op) == CAT_NEW) {
            escapes.insert(op);
          } else {
            /*
            // can `op` alias with something?
            for (const auto &must : meta.getMustAlias(op)) {
              if (const auto &select = dyn_cast<SelectInst>(must)) {
                for (const auto &ref : meta.storeEscapes[select->getTrueValue()]) {
                if (getCATFuncType(ref) == CAT_NEW) {
                  escapes.insert(ref);
                  }
                }
                for (const auto &ref : meta.storeEscapes[select->getFalseValue()]) {
                if (getCATFuncType(ref) == CAT_NEW) {
                  escapes.insert(ref);
                  }
                }
              }
            }
            */
          }
        }
      }
      return escapes;
    }

    static bool isCAT(const Value *value) {
      return getCATFuncType(value) != CAT_INVALID;
    }

    static bool isCATModifier(const Value *value) {
      CAT_TYPE type = getCATFuncType(value);
      return type == CAT_NEW || type == CAT_ADD || type == CAT_SUB || type == CAT_SET;
    }

    static bool isCATEscape(const Value *value) {
      if (const auto &callInst = dyn_cast<CallInst>(value)) {
        for (const auto &op : callInst->args()) {
          if (getCATFuncType(op) == CAT_NEW) {
            return true;
          }
        }
      } else if (const auto &store = dyn_cast<StoreInst>(value)) {
        if (getCATFuncType(store->getValueOperand()) == CAT_NEW) {
          return true;
        }
      }
      return false;
    }

    void printSet(
        FunctionMetadata &meta,
        const std::vector<Bits>& sets,
        const Instruction *inst
        ) {
      for (const auto &idx : sets[meta.instToIndex[inst]]) {
        errs() << *meta.indexToInst[idx] << "\n";
      }
    }

    std::string modRefInfoToString(const ModRefInfo &info) {
      switch (info) {
        case ModRefInfo::ModRef: return "ModRef";
        case ModRefInfo::Mod: return "Mod";
        case ModRefInfo::Ref: return "Ref";
        case ModRefInfo::MustRef: return "MustRef";
        case ModRefInfo::MustMod: return "MustMod";
        case ModRefInfo::MustModRef: return "MustModRef";
        case ModRefInfo::NoModRef: return "NoModRef";
        default: return "Unknown";
      }
    }

    bool phiOnlyHasCATNews(
        const PHINode *phi,
        std::set<const PHINode*> &explored
        ) {
      if (explored.find(phi) != explored.end()) { // to defeat infinite recursions
        return false;
      }
      explored.insert(phi);
      for (const auto &val : phi->incoming_values()) {
        if (const auto &childPhi = dyn_cast<PHINode>(val)) {
          if (!phiOnlyHasCATNews(childPhi, explored)) {
            return false;
          }
        } else if (getCATFuncType(val) != CAT_NEW) {
          return false;
        }
      }
      return true;
    }

    bool phiOnlyHasCATNews(const PHINode *phi) {
      std::set<const PHINode*> explored;
      return phiOnlyHasCATNews(phi, explored);
    }

    bool calleeModifiesArgs(FunctionMetadata &meta, AAResults &aa, const CallInst *call) {
      for (const auto &arg : call->args()) {
        auto mrInfo = aa.getModRefInfo(call, arg, getValueMemSize(meta.F, arg));
        switch (mrInfo) {
          case ModRefInfo::ModRef:
          case ModRefInfo::Mod:
            //case ModRefInfo::MustMod:
            //case ModRefInfo::MustModRef:
            return true;
          default: break;
        }
      }
      return false;
    }

    void exploreAndKill(
        FunctionMetadata &meta,
        const Instruction *sender,
        const Value *target,
        Bits& kill
        ) {
      if (isa<PHINode>(target)) {
        if (target != sender) {
          kill.set(meta.instToIndex[cast<Instruction>(target)]);
        }
      }
      if (isa<StoreInst>(sender)) {
        kill.set(meta.instToIndex[cast<Instruction>(target)]);
      }
      for (const auto &user : target->users()) {
        if (user == sender) { // don't kill yourself
          continue;
        }
        if (const auto userCall = dyn_cast<CallInst>(user)) {
          if ((isCATModifier(userCall) && userCall->getArgOperand(0) == target) ||
              !isCAT(userCall)) {
            kill.set(meta.instToIndex[cast<Instruction>(userCall)]);
          }
        }
      }
    }

    void computeGen(FunctionMetadata &meta, AAResults &aa) {
      for (const auto &inst : instructions(*meta.F)) {
        Bits gen;

        if (const auto &phi = dyn_cast<PHINode>(&inst)) {
          if (phiOnlyHasCATNews(phi)) {
            gen.set(meta.instToIndex[&inst]);
          }
          // TODO: the following else-if block and the one below it
          // cover some of the same cases because `isCATEscape`
          // captures both `StoreInst`s and `CallInst`s. Best to rewrite this.
        } else if (const auto &store = dyn_cast<StoreInst>(&inst)) {
          if (isCATEscape(store)) {
            std::set<const Value*> toGen;
            for (const auto &op : inst.operands()) {
              if (isa<Instruction>(op)) {
                auto mayAlias = meta.getMayAlias(op);
                auto mustAlias = meta.getMustAlias(op);
                toGen.insert(mayAlias.begin(), mayAlias.end());
                toGen.insert(mustAlias.begin(), mustAlias.end());
              }
            }
            for (const auto i : toGen) {
              gen.set(meta.instToIndex[cast<Instruction>(i)]);
            }
          }
        } else if (const auto *call = dyn_cast<CallInst>(&inst)) {
          if (isCATModifier(&inst) || isCATEscape(&inst)) {
            const auto cType = getCATFuncType(&inst);
            if (cType != CAT_GET) {
              // all CAT escapes generate themselves except for CAT_GETs
              // but only is the call might modify its arguments
              gen.set(meta.instToIndex[&inst]);
            }
          }
        }
        meta.gen.push_back(gen);
      }
    }

    void computeKill(FunctionMetadata &meta, AAResults &aa) {
      for (const auto &inst : instructions(*meta.F)) {
        Bits kill;

        if (const auto &phi = dyn_cast<PHINode>(&inst)) {
          if (phiOnlyHasCATNews(phi)) {
            exploreAndKill(meta, &inst, phi, kill);
          }
        } else if (const auto &store = dyn_cast<StoreInst>(&inst)) {
          if (isCATEscape(store)) {
            //exploreAndKill(meta, &inst, store->getValueOperand(), kill);
            std::set<const Value*> toKill;
            for (const auto &op : inst.operands()) {
              if (isa<Instruction>(op)) {
                auto mustAlias = meta.getMustAlias(op);
                toKill.insert(mustAlias.begin(), mustAlias.end());
              }
            }
            for (const auto i : toKill) {
              kill.set(meta.instToIndex[cast<Instruction>(i)]);
            }
          }
        } else if (const auto callInst = dyn_cast<CallInst>(&inst)) {
          if (true || isCATModifier(&inst) || isCATEscape(&inst)) {
            const auto cType = getCATFuncType(&inst);
            std::set<const Value*> toKill;
            switch (cType) {
              case CAT_NEW:
                toKill.insert(&inst);
                break;
              case CAT_SET:
              case CAT_ADD:
              case CAT_SUB:
                toKill.insert(callInst->getArgOperand(0));
                break;
              case CAT_INVALID: // unknown function that uses (==> changes) a CATData
                if (calleeModifiesArgs(meta, aa, callInst)) {
                  toKill = getEscapedCATValues(meta, &inst);
                }
                break;
              default: break; // should not happen
            }
            // killing one CATData reference at a time
            for (const auto &killMe : toKill) {
              if (killMe != &inst && getCATFuncType(killMe) == CAT_NEW) {
                // kill a CAT_NEW except when it's the current instruction (`inst`)
                kill.set(meta.instToIndex[cast<Instruction>(killMe)]);
              }
              exploreAndKill(meta, &inst, killMe, kill);
            }
          }
        }
        meta.kill.push_back(kill);
      }
    }

    void computeGenKillSets(FunctionMetadata &meta, AAResults &aa) {
      meta.gen.reserve(meta.F->getInstructionCount());
      meta.kill.reserve(meta.F->getInstructionCount());

      computeGen(meta, aa);
      computeKill(meta, aa);
    }

    void printGenKillSets(FunctionMetadata &meta) {
      errs() << "Function \"" << meta.F->getName() << "\" \n";
      for (const auto &inst : instructions(*meta.F)) {
        errs() << "INSTRUCTION: " << inst << "\n";
        errs() << "***************** GEN\n";
        errs() << "{\n";
        for (const auto &idx : meta.gen[meta.instToIndex[&inst]]) {
          errs() << " " << *meta.indexToInst[idx] << "\n";
        }
        errs() << "}\n";
        errs() << "**************************************\n";
        errs() << "***************** KILL\n";
        errs() << "{\n";
        for (const auto &idx : meta.kill[meta.instToIndex[&inst]]) {
          errs() << " " << *meta.indexToInst[idx] << "\n";
        }
        errs() << "}\n";
        errs() << "**************************************\n";
        errs() << "\n\n\n";
      }
    }

    void printInOutSets(FunctionMetadata &meta) {
      errs() << "Function \"" << meta.F->getName() << "\" \n";
      for (const auto &inst : instructions(*meta.F)) {
        errs() << "INSTRUCTION: " << inst << "\n";
        errs() << "***************** IN\n";
        errs() << "{\n";
        for (const auto &idx : meta.in[meta.instToIndex[&inst]]) {
          errs() << " " << *meta.indexToInst[idx] << "\n";
        }
        errs() << "}\n";
        errs() << "**************************************\n";
        errs() << "***************** OUT\n";
        errs() << "{\n";
        for (const auto &idx : meta.out[meta.instToIndex[&inst]]) {
          errs() << " " << *meta.indexToInst[idx] << "\n";
        }
        errs() << "}\n";
        errs() << "**************************************\n";
        errs() << "\n\n\n";
      }
    }

    void computeInOutSets(FunctionMetadata &meta) {
      meta.in.resize(meta.gen.size());
      meta.out.resize(meta.gen.size());

      // compute the gen and killset of each _basic block_ before starting
      std::unordered_map<const BasicBlock*, Bits> bbGen;
      std::unordered_map<const BasicBlock*, Bits> bbKill;
      for (const auto &bb : *meta.F) {
        // notice the reverse iteration order (ie. rbegin()/rend())
        for (auto i = bb.rbegin(); i != bb.rend(); i++) {
          auto idx = meta.instToIndex[&(*i)];
          // adding (genset of this instruction minus union of killsets of all successors)
          // bbGen[bb] "contains all definitions in block B that are _visible_ immediately after B"
          auto newGen = meta.gen[idx];
          newGen.intersectWithComplement(bbKill[&bb]);
          bbGen[&bb] |= newGen;
          // bbKill[bb] "contains all definitions killed by instructions in block B"
          bbKill[&bb] |= meta.kill[idx];
        }
      }

      std::deque<const BasicBlock*> workList;
      for (const auto &bb : *meta.F) {
        workList.push_back(&bb);
      }

      while (!workList.empty()) {
        const auto bb = workList.front();
        workList.pop_front();

        const auto first = bb->begin(); // we will use IN[B.first] as IN[B]
        const auto firstIdx = meta.instToIndex[&(*first)];
        const auto last = bb->getTerminator(); // we will use OUT[B.last] as OUT[B]
        const auto lastIdx = meta.instToIndex[last];
        const auto oldOut = meta.out[lastIdx];

        // IN = U[OUT[p]] | p = {predecessor of bb}
        for (const auto &predBb : predecessors(bb)) {
          const auto predOutIdx = meta.instToIndex[predBb->getTerminator()];
          // we can always use |= since inSet bits can never flip from 1->0
          meta.in[firstIdx] |= meta.out[predOutIdx];
        }
        // OUT = GEN U (IN - KILL)
        meta.out[lastIdx] = meta.in[firstIdx];
        meta.out[lastIdx].intersectWithComplement(bbKill[bb]); // IN[B]-KILL[B]
        meta.out[lastIdx] |= bbGen[bb]; // ... U GEN[B]

        if (oldOut != meta.out[lastIdx]) {
          for (const auto &succ : successors(bb)) {
            workList.push_back(succ);
          }
        }
      }

      for (const auto &bb : *meta.F) {
        // Handling instructions within a BasicBlock
        for (auto i = bb.begin(); i != bb.end(); i++) {
          const auto inst = &(*i);
          const auto idx = meta.instToIndex[inst];
          if (i != bb.begin()) {
            // IN[B.first] == IN[B], so it doesn't make sense to compute it
            const auto predInst = &(*std::prev(i));
            const auto predIdx = meta.instToIndex[predInst];
            // IN
            meta.in[idx] = meta.out[predIdx];
          }
          // OUT
          meta.out[idx] = meta.in[idx];
          meta.out[idx].intersectWithComplement(meta.kill[idx]); // IN[B]-KILL[B]
          meta.out[idx] |= meta.gen[idx]; // ... U GEN[B]
        }
      }
    }

    ConstantInt* sameConstantInt(const std::set<Value*> &values) {
      if (values.size() == 0) {
        return nullptr;
      }
      const auto target = dyn_cast<ConstantInt>(*values.begin());
      if (target == nullptr) {
        return nullptr;
      }
      const auto targetInt = target->getSExtValue();
      for (auto iter = values.begin(); iter != values.end(); iter++) {
        const auto current = dyn_cast<ConstantInt>(*iter);
        if (current == nullptr || current->getSExtValue() != targetInt) {
          return nullptr;
        }
      }
      return target;
    }

    ConstantInt* getPhiSingleDefinition(FunctionMetadata &meta, const PHINode *phi) {
      std::set<Value*> values;
      for (const auto &val : phi->incoming_values()) {
        Value* newDef = nullptr;
        if (const auto &childPhi = dyn_cast<PHINode>(val)) {
          newDef = getPhiSingleDefinition(meta, childPhi);
        }
        else if (getCATFuncType(val) == CAT_NEW) {
          newDef = cast<CallInst>(val)->getArgOperand(0);
        }
        if (newDef == nullptr) {
          return nullptr;
        }
        values.insert(newDef);
      }
      return sameConstantInt(values);
    }

    // return nullptr if definition of `inst` in `inSet` is not unique. Return the definition otherwise.
    ConstantInt* getSingleConstDef(
        FunctionMetadata &meta,
        const Value *target,
        const Instruction& inst
        ) {
      const auto targetIn = meta.in[meta.instToIndex[&inst]];

      std::set<Value*> candidateDefs;
      std::set<const CallInst*> calls;
      for (int idx : targetIn) {
        const auto inst = meta.indexToInst[idx];
        if (inst == target) {
          if (getCATFuncType(inst) == CAT_NEW) {
            candidateDefs.insert(cast<CallInst>(inst)->getArgOperand(0));
          } else if (const auto &phi = dyn_cast<PHINode>(inst)) {
            // check if incoming values represent the same constant int
            auto phiDef = getPhiSingleDefinition(meta, phi);
            if (phiDef == nullptr) {
              return nullptr;
            }
            candidateDefs.insert(phiDef);
          }
        } else if (const auto &call = dyn_cast<CallInst>(inst)) {
          if (call->hasArgument(target)) {
            const auto cType = getCATFuncType(call);
            if (cType == CAT_SET) {
              candidateDefs.insert(call->getArgOperand(1));
              calls.insert(call);
            } else if (cType == CAT_INVALID) {
              return nullptr; // since `call` is an unknown external function
            } else if ((cType == CAT_ADD || cType == CAT_SUB) &&
                (call->getArgOperand(0) == target)) {
              return nullptr; // since `call` changes the target
            }
          }
        } else if (const auto &load = dyn_cast<LoadInst>(inst)) {
          const auto op = load->getPointerOperand();
          if (const auto &phi = dyn_cast<PHINode>(op)) {
            const auto *inc = &*(phi->incoming_values().begin());
            if (const auto &select = dyn_cast<SelectInst>(inc)) {
              if (isa<AllocaInst>(select->getTrueValue())) {
                return nullptr;
              }
            }
          } else if (const auto &select = dyn_cast<SelectInst>(op)) {
            if (isa<AllocaInst>(select->getTrueValue())) {
              return nullptr;
            }
          }
        }
      }

      auto def = sameConstantInt(candidateDefs);
      if (def == nullptr) {
        return nullptr;
      }

      // an argument must be handled differently since it holds an
      // implicit definition of itself, but if it is post-dominated
      // by any candidate then it is valid to proceed.
      if (isa<Argument>(target)) {
        const auto &first = &*(meta.F->begin()->begin());
        for (const auto &call : calls) {
          if (meta.pdt.dominates(call, first)) {
            // `target` is overwritten by at least one call that gens
            // a candidate definition.
            return def;
          }
        }
        // no instruction that gens a candidate def post-dominates
        // the first instruction of the function, therefore the initial
        // value of the parameter may be alive.
        return nullptr;
      }

      return def;
    }

    int getValueMemSize(Function *F, const Value *val) {
      if (auto pointerType = dyn_cast<PointerType>(val->getType())) {
        auto pointeeType = pointerType->getPointerElementType();
        if (pointeeType->isSized()) {
          return F->getParent()->getDataLayout().getTypeStoreSize(pointeeType);
        }
      }
      return -1;
    }

    bool applyConstantPropagation(FunctionMetadata &meta) {
      std::vector<std::pair<Instruction*, ConstantInt*>> constPropMap;
      for (auto &inst : instructions(*meta.F)) {
        if (getCATFuncType(&inst) != CAT_GET) {
          continue;
        }
        // checking if the target instruction has only one reaching definition
        const auto CATVar = cast<CallInst>(&inst)->getArgOperand(0); // this is a call to CAT_new
        if (auto defValue = getSingleConstDef(meta, CATVar, inst)) {
          constPropMap.push_back(std::make_pair(&inst, defValue)); // saving the propagation for later
        }
        /*else {
          errs() << " >>> " << inst << "\n   ^ not single def\n";
          printSet(meta, meta.in, &inst);
          }*/
      }

      // modifying the IR

      IRBuilder<> builder(meta.F->getContext());

      // `inst` is the instruction (CAT_get) to be patched with `defValue`
      for (auto &[inst, constant] : constPropMap) {
        //auto constant = dyn_cast<ConstantInt>(defValue);
        //errs() << "[CP] " << *inst << "\n";
        //errs() << "   ^ " << *constant << "\n";
        //printSet(meta, meta.in, inst);

        // IR transformation
        builder.SetInsertPoint(inst);
        BasicBlock::iterator ii(inst);
        ReplaceInstWithValue(inst->getParent()->getInstList(), ii, constant);
      }

      bool IRChanged = constPropMap.size() > 0;
      return IRChanged;
    }


    bool applyConstantFolding(
        FunctionMetadata &meta
        ) {
      std::vector<std::pair<Instruction*, ConstantInt*>> constFoldingMap;

      for (auto &inst : instructions(*meta.F)) {
        const auto cType = getCATFuncType(&inst);

        if (!(cType == CAT_ADD || cType == CAT_SUB)) {
          continue;
        }

        // checking if the target instruction has only one reaching definition
        const auto operand1 = cast<CallInst>(&inst)->getArgOperand(1);
        const auto operand2 = cast<CallInst>(&inst)->getArgOperand(2);
        const auto val1 = getSingleConstDef(meta, operand1, inst);
        const auto val2 = getSingleConstDef(meta, operand2, inst);

        // only apply transformation if operands are ConstantInt because otherwise it gets too complicated
        if (val1 == nullptr || val2 == nullptr) {
          //errs() << *defVal1 << "\n" << *defVal2 << "\n";
          //errs() << "  ^ folding unapplicable [non-ConstantInt values]\n";
          continue;
        }

        int64_t newInt;
        switch (cType)
        {
          case CAT_ADD:
            newInt = val1->getSExtValue() + val2->getSExtValue();
            break;
          case CAT_SUB:
            newInt = val1->getSExtValue() - val2->getSExtValue();
            break;
          default:
            //errs() << "[CF] error: should not be here\n";
            continue;
            break;
        }

        constFoldingMap.push_back(std::make_pair(&inst, ConstantInt::get(Type::getInt64Ty(meta.F->getContext()), newInt))); // saving the propagation for later
                                                                                                   //errs() << "[CF] " << inst << "\n";
                                                                                                   //errs() << "   ^ f(" << val1->getSExtValue() << ", " << val2->getSExtValue() << ") = " << newInt << "\n";
      }

      // modifying the IR

      LLVMContext &context = meta.F->getContext();
      IRBuilder<> builder(context);
      FunctionType *fType = FunctionType::get(Type::getVoidTy(context), { Type::getInt8PtrTy(context), Type::getInt64Ty(context) }, false);
      FunctionCallee fCallee = meta.F->getParent()->getOrInsertFunction("CAT_set", fType);

      // `inst` is the instruction (CAT_add or CAT_sub) to be patched with the operands of `cInst1` and `cInst2`
      for (auto &[inst, newValue] : constFoldingMap) {
        Value *destination = cast<CallInst>(inst)->getArgOperand(0);

        // creating the new function call (CAT_set)
        builder.SetInsertPoint(inst);
        builder.CreateCall(fCallee, { destination, newValue });
        inst->eraseFromParent();
      }

      bool IRChanged = constFoldingMap.size() > 0;
      return IRChanged;
    }

    bool applyZeroFolding(FunctionMetadata &meta) {
      std::unordered_map<CallInst*, Value*> zeroFoldingMap;

      for (auto &inst : instructions(*meta.F)) {
        if (getCATFuncType(&inst) == CAT_SUB) {
          CallInst *call = cast<CallInst>(&inst);
          if (call->getArgOperand(1) == call->getArgOperand(2)) {
            zeroFoldingMap[call] = call->getArgOperand(0);
            errs() << "[ZF] " << *call << "\n";
          }
        }
      }

      // modifying the IR

      LLVMContext &context = meta.F->getContext();
      IRBuilder<> builder(context);
      FunctionType *fType = FunctionType::get(Type::getVoidTy(context), { Type::getInt8PtrTy(context), Type::getInt64Ty(context) }, false);
      FunctionCallee fCallee = meta.F->getParent()->getOrInsertFunction("CAT_set", fType);
      Constant *zeroConst = ConstantInt::get(IntegerType::get(meta.F->getParent()->getContext(), 64), 0, true);

      for (auto &[call, op] : zeroFoldingMap) {
        // resetting `op` to zero with a CAT_set
        builder.SetInsertPoint(call);
        builder.CreateCall(fCallee, { op, zeroConst });
        call->eraseFromParent();
      }

      bool IRChanged = zeroFoldingMap.size() > 0;
      return IRChanged;
    }

    // This function is invoked once at the initialization phase of the compiler
    // The LLVM IR of functions isn't ready at this point
    bool doInitialization(Module &M) override {
      return false;
    }

    // returns set of calls to F if the number of direct calls to F is lower than `max`, else returns an empty vec
    std::vector<CallBase*> fewCalls(Function& F, uint64_t max) {
      std::vector<CallBase*> calls;
      for (auto user : F.users()) {
        if (auto call = dyn_cast<CallBase>(user)) {
          calls.push_back(call);
          if (calls.size() > max) {
            return std::vector<CallBase*> {};
          }
        }
      }
      return calls;
    }

    bool hasCATCalls(Function& F) {
      for (const auto &i : instructions(F)) {
        if (isa<CallInst>(i) && getCATFuncType(&i) != CAT_INVALID) {
          return true;
        }
      }
      return false;
    }

    bool applyInlining(Function &F) {
      auto IRChanged = false;
      if (hasCATCalls(F)) {
        for (auto call : fewCalls(F, MAX_CALLS)) {
          InlineFunctionInfo IFI;
          IRChanged |= llvm::InlineFunction(*call, IFI).isSuccess();
        }
      }
      return IRChanged;
    }

    bool runOnModule(Module &M) override {
      auto IRChanged = false;
      ModuleMetadata modMeta(M);

      for (auto &F : M) {
        if (F.empty()) {
          continue; // we can't analyze functions whose bodies are unavailable
        } 
        IRChanged |= applyInlining(F);
      }
      if (IRChanged) { return IRChanged; }

      for (auto &F : M) {
        if (F.empty()) {
          continue; // we can't analyze functions whose bodies are unavailable
        } 
        AliasAnalysis &aa = getAnalysis<AAResultsWrapperPass>(F).getAAResults();
        modMeta[&F] = FunctionMetadata();
        modMeta[&F].initialize(F, aa);
        //modMeta[&F].refine(); // custom Alias Analysis

        // Computing GEN and KILL
        computeGenKillSets(modMeta[&F], aa);

        // Computing IN and OUT
        computeInOutSets(modMeta[&F]);

        // IR transformations
        IRChanged |= applyConstantPropagation(modMeta[&F]);
        //IRChanged |= applyZeroFolding(modMeta[&F]);
        //IRChanged |= applyConstantFolding(modMeta[&F]);
      }
      return IRChanged;
    }

    // We don't modify the program, so we preserve all analyses.
    // The LLVM IR of functions isn't ready at this point
    void getAnalysisUsage(AnalysisUsage &AU) const override {
      //AU.setPreservesAll();
      AU.addRequired<AAResultsWrapperPass>();
    }
  };
}

// Next there is code to register your pass to "opt"
char CAT::ID = 0;
static RegisterPass<CAT> X("CAT", "Homework for the CAT class");

// Next there is code to register your pass to "clang"
static CAT * _PassMaker = NULL;
static RegisterStandardPasses _RegPass1(PassManagerBuilder::EP_OptimizerLast,
    [](const PassManagerBuilder&, legacy::PassManagerBase& PM) {
    if(!_PassMaker){ PM.add(_PassMaker = new CAT());}}); // ** for -Ox
static RegisterStandardPasses _RegPass2(PassManagerBuilder::EP_EnabledOnOptLevel0,
    [](const PassManagerBuilder&, legacy::PassManagerBase& PM) {
    if(!_PassMaker){ PM.add(_PassMaker = new CAT()); }}); // ** for -O0
